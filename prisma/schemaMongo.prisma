generator client {
  provider     = "prisma-client"
  output       = "../src/generated/prismaMongo"
  moduleFormat = "cjs"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL_MONGO")
}

//////////////////////////////////////////////////////////
// 1. cultivo_params  
// Guarda los parámetros óptimos por categoría de sensor
//
// - id_cultivo: viene de PostgreSQL (tabla cultivo)
// - params: parámetros óptimos por sensor_category
//////////////////////////////////////////////////////////

type CultivoParamsParams {
  category_id       Int
  category_name     String
  description       String
  max               Int
  min               Int
  optimal           Int
  unidad_medicion   String
  warning_threshold Int
}
model cultivo_params {
  id          Int                   @id @map("_id")
  id_cultivo  Int                   
  params      CultivoParamsParams[]
}

//////////////////////////////////////////////////////////
// 2. growth_stages 
// Define las ETAPAS de crecimiento de un cultivo.
//
// Un cultivo puede tener etapas como:
//  - Germinación
//  - Crecimiento
//  - Desarrollo
//  - Madurez
//
// Estas etapas se copiarán cuando una parcela inicie un ciclo.
//////////////////////////////////////////////////////////

model growth_stages {
  id               String   @id @default(uuid()) @map("_id")

  cultivo_id       Int         
  cultivo_nombre   String      

  stages           StageDefinition[]
}

type StageDefinition {
  stage_index      Int
  stage_name       String             
  description      String?            
  expected_days    Int?               

  optimal_conditions OptimalCondition[]
}

type OptimalCondition {
  id_sensor  Int                   
  min        Float
  max        Float
  optimal    Float
}

//////////////////////////////////////////////////////////
// 3. parcela_cycles 
// Cada parcela puede tener múltiples ciclos de cultivo.
//
// Ejemplo:
//  Ciclo 1 → Germinación → Crecimiento → Cosecha
//  Ciclo 2 → Germinación → Crecimiento → Cosecha
//
// Cada ciclo tendrá sus PROPIAS etapas y lecturas IoT.
//////////////////////////////////////////////////////////

model parcela_cycles {
  id_cycle     String   @id @default(uuid()) @map("_id")

  id_parcela   Int          
  ciclo_num    Int          

  // Relación al cultivo del ciclo
  cultivo_id   Int
  cultivo_name String

  startDate    DateTime
  endDate      DateTime?

  // Etapas reales del ciclo
  stages       CycleStage[]
}

//////////////////////////////////////////////////////////
// 4. CycleStage
// Una etapa dentro de un ciclo, con lecturas IoT incluidas.
//////////////////////////////////////////////////////////

type CycleStage {
  stage_index  Int
  stage_name   String

  startDate    DateTime
  endDate      DateTime?

  readings     IotReading[]
}

//////////////////////////////////////////////////////////
// 5. IotReading 
// Lecturas de los sensores
//////////////////////////////////////////////////////////

type IotReading {
  id_iot         Int
  hora           DateTime
  image_url      String
  image_result   String?
  overall_status String?

  sensorReadings SensorReading[]
}

type SensorReading {
  id_sensor  Int
  lectura    Float
  status     String?
  deviation  Float?
  message    String?
}

//////////////////////////////////////////////////////////
// 6. chat_histories 
// Historial de chat por usuario/parcela. No depende del ciclo.
//////////////////////////////////////////////////////////

model chat_histories {
  id         String   @id @default(uuid()) @map("_id")  
  userId     Int                                      
  parcelaId  Int                                      
  messages   Message[]                                
  createdAt  DateTime @default(now())                 
  updatedAt  DateTime @updatedAt                      
  @@unique([userId, parcelaId])
}

type Message {
  role      String    
  content   String   
  timestamp DateTime  
}
